// Lark grammar for debug sequence expressions
//
// Copyright (c) 2020-2021 Chris Reed
// SPDX-License-Identifier: Apache-2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Precedence from high to low:
// 1. function call, parentheses
// 2. unary ! ~
// 3. * / %
// 4. + -
// 5. << >>
// 6. < <= > >=
// 7. == !=
// 8. &
// 9. ^
// 10. |
// 11. &&
// 12. ||
// 13. ?:

start:                  statement*

?statement:             decl_stmt ";"?
    |                   assign_stmt ";"?
    |                   expr_stmt ";"?

// Allow __var declarations with no initialiser expression even though this is disallowed
// by the specification, for greater compatibility.
decl_stmt:              "__var" IDENT ["=" expr]

assign_stmt:            IDENT _compound_assign_op expr

// This creates a tree node for expression statements that is easy to identify.
expr_stmt:              expr

?expr:                  logical_or_expr
    |                   ternary_expr
    |                   STRLIT

ternary_expr:           expr "?" expr ":" expr

?logical_or_expr:       logical_and_expr
    |                   logical_or_expr _logor_op logical_and_expr -> binary_expr

?logical_and_expr:      bitwise_or_expr
    |                   logical_and_expr _logand_op bitwise_or_expr -> binary_expr

?bitwise_or_expr:       bitwise_xor_expr
    |                   bitwise_or_expr _bitor_op bitwise_xor_expr -> binary_expr

?bitwise_xor_expr:      bitwise_and_expr
    |                   bitwise_xor_expr _bitxor_op bitwise_and_expr -> binary_expr

?bitwise_and_expr:      equality_expr
    |                   bitwise_and_expr _bitand_op equality_expr -> binary_expr

?equality_expr:         relational_expr
    |                   equality_expr _eq_op relational_expr -> binary_expr

?relational_expr:       bitwise_shift_expr
    |                   relational_expr _compare_op bitwise_shift_expr -> binary_expr

?bitwise_shift_expr:    add_expr
    |                   bitwise_shift_expr _shift_op add_expr -> binary_expr

?add_expr:              multiply_expr
    |                   add_expr _add_op multiply_expr -> binary_expr

?multiply_expr:         atom
    |                   multiply_expr _mul_op atom -> binary_expr

?atom:                  IDENT
    |                   INTLIT
    |                   fncall
    |                   "(" expr ")"
    |                   unary_expr

unary_expr:            _unary_op atom

fncall:                 IDENT "("  ")"
    |                   IDENT "(" expr ( "," expr )* ")"

// The ! prefix forces all literals to be included in the tree.
// Underscore prefix merges the rule into its parent.
!_logor_op: "||"
!_logand_op: "&&"
!_bitor_op: "|"
!_bitxor_op: "^"
!_bitand_op: "&"
!_eq_op: "==" | "!="
!_shift_op: "<<" | ">>"
!_compare_op: "<=" | "<" | ">=" | ">"
!_add_op: "+" | "-"
!_mul_op: "*" | "/" | "%"
!_unary_op: "!" | "~" | "-" | "+"
!_compound_assign_op: "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" | "="

BINDIGIT: "0".."1"
INTLIT: ( "0x" HEXDIGIT+ | "0b" BINDIGIT+ | DIGIT+ ) ( "u" | "U" )?

STRLIT: ESCAPED_STRING

IDENT: CNAME

COMMENT: /\s*/ "//" /[^\n]*/

%import common.DIGIT
%import common.HEXDIGIT
%import common.ESCAPED_STRING
%import common.WS
%import common.CNAME

%ignore WS
%ignore COMMENT
